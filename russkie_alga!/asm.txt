def main:
in
pop [bx+0]
in
pop [bx+1]
in
pop [bx+2]
push 1
pop [bx+3]
push 2
pop [bx+4]
push 3
pop [bx+5]
push 4
pop [bx+6]
push 0
push [bx+0]
jne :if0
push 0
push [bx+1]
jne :if1
push 0
push [bx+2]
jne :if2
push [bx+6]
pop ax
hlt

def if2:
say
def if1:
say
def if0:
say
push 0
push [bx+0]
jne :if3
push bx

push [bx+2]
push [bx+1]
push bx
push 11
add
pop bx
pop [bx+0]
pop [bx+1]

call :linear
pop bx
push ax
pop [bx+7]
push [bx+7]
pop ax
hlt

def if3:
say
push 0
push [bx+1]
jne :if4
push 1
push 0
sub
push [bx+0]
push [bx+2]
saw
mlt
pop [bx+8]
push 1
push 0
sub
push [bx+8]
jbe :if5
push [bx+8]
sqrt
pop [bx+9]
push [bx+9]
push 1
push 0
sub
mlt
pop [bx+10]
push [bx+10]
push [bx+9]
out
pop 0
out
pop 0
push [bx+4]
pop ax
hlt

def if5:
say
push 33
pop [bx+0]
push [bx+5]
pop ax
hlt

def if4:
say
push 0
push [bx+2]
jne :if6
push 0
pop [bx+9]
push [bx+9]
out
pop 0
push bx

push [bx+1]
push [bx+0]
push bx
push 11
add
pop bx
pop [bx+0]
pop [bx+1]

call :linear
pop bx
push ax
pop [bx+7]
push [bx+3]
push [bx+7]
jne :if7
push [bx+4]
pop ax
hlt

def if7:
say
push [bx+3]
pop ax
hlt

def if6:
say
push bx

push [bx+2]
push [bx+1]
push [bx+0]
push bx
push 11
add
pop bx
pop [bx+0]
pop [bx+1]
pop [bx+2]

call :SolveViaD
pop bx
push ax
pop [bx+7]
push [bx+7]
pop ax
hlt

def linear:
push 1
pop [bx+2]
push 3
pop [bx+3]
push 0
push [bx+0]
jne :if8
push [bx+3]
pop ax
ret

def if8:
say
push [bx+0]
push [bx+1]
push 1
push 0
sub
mlt
saw
pop [bx+4]
push [bx+4]
out
pop 0
push [bx+2]
pop ax
ret

def SolveViaD:
push 2
pop [bx+3]
push 3
pop [bx+4]
push [bx+2]
push [bx+0]
push 4
mlt
mlt
push [bx+1]
push [bx+1]
mlt
sub
pop [bx+5]
push [bx+5]
sqrt
pop [bx+6]
push [bx+0]
push 2
mlt
pop [bx+7]
push 1
push 0
sub
push [bx+5]
jbe :if9
push [bx+7]
push [bx+6]
push [bx+1]
push 0
sub
add
saw
pop [bx+8]
push [bx+7]
push [bx+6]
push [bx+1]
push 0
sub
sub
saw
pop [bx+9]
push [bx+9]
push [bx+8]
out
pop 0
out
pop 0
push [bx+3]
pop ax
ret

def if9:
say
push [bx+4]
pop ax
ret

say